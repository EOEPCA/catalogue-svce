sudo: required
language: java
install: false #true



services:
  - docker

jobs:
  include:
    - stage: build (compile, unit test, package)
      jdk: openjdk10
      script:
        - ./gradlew build #--scan -s
        #  - ls -l build/libs
        - docker build -t eoepca/catalogue-service .
        #  - docker images
        - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin
        - docker tag eoepca/catalogue-service $DOCKER_USERNAME/catalogue-service:travis_$TRAVIS_BUILD_NUMBER
        - docker push $DOCKER_USERNAME/catalogue-service:travis_$TRAVIS_BUILD_NUMBER   # defaults to docker hub
      
    - stage: smoke and acceptance test
      install: skip  # without this there's a git clone and gradlew assemble executed! 
      script:
        - docker run -d --rm -p 8080:7000 --name cat-svc $DOCKER_USERNAME/catalogue-service:travis_$TRAVIS_BUILD_NUMBER
        - sleep 15  # wait for startup
      #  - docker ps -a
        - curl -s http://localhost:8080/search | jq '.'  # trivial smoke test
      #  - docker logs cat-svc
      
    - stage: release
      if: branch = master
      install: skip
      script:
        - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin
        - docker pull $DOCKER_USERNAME/catalogue-service:travis_$TRAVIS_BUILD_NUMBER  # have to pull locally in order to tag as a release 
        - docker tag $DOCKER_USERNAME/catalogue-service:travis_$TRAVIS_BUILD_NUMBER $DOCKER_USERNAME/catalogue-service:release_$TRAVIS_BUILD_NUMBER
        - docker push $DOCKER_USERNAME/catalogue-service:release_$TRAVIS_BUILD_NUMBER
        - docker tag $DOCKER_USERNAME/catalogue-service:travis_$TRAVIS_BUILD_NUMBER $DOCKER_USERNAME/catalogue-service:latest
        - docker push $DOCKER_USERNAME/catalogue-service:latest
    
    - stage: production

      if: branch = master # depends on release stage so this should be redundant

      install: skip

      # Minikube installation taken from: https://github.com/LiliC/travis-minikube/blob/minikube-30-kube-1.12/.travis.yml

      # We need the systemd for the kubeadm and it's default from 16.04+
      dist: xenial

      env: 
        - CHANGE_MINIKUBE_NONE_USER=true
        - K8S_VER=v1.12.0

      before_script:
        # Make root mounted as rshared to fix kube-dns issues.
        - sudo mount --make-rshared /
        - echo "Installing minikube and kubectl version $K8S_VER"
        - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v1.12.0/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/
        - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.30.0/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/
        - sudo minikube start --vm-driver=none --bootstrapper=kubeadm --kubernetes-version=v1.12.0
        # Fix the kubectl context, as it's often stale.
        - minikube update-context
        # Wait for Kubernetes to be up and ready.
        - JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}'; until kubectl get nodes -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do sleep 1; done
        - kubectl cluster-info        

      script:
        - kubectl apply -f kubernetes/micro-service.yaml
        - kubectl apply -f kubernetes/rev-proxy.yaml        
        - sleep 60
        - kubectl get nodes
        - kubectl get pods --all-namespaces
        - kubectl get deployments catalogue-service-deployment
        #- kubectl logs -lapp=catalogue-service --all-containers=true
        - kubectl logs deployment/catalogue-service-deployment --all-containers=true
        - kubectl logs deployment/frontend --all-containers=true
        #- kubectl expose deployment catalogue-service-deployment --name=cat-svce2 --port=8083 --target-port=7000 --type=NodePort
        #- kubectl get svc cat-svce
        - kubectl get service cat-svce -o json        
        - nodePort=$(kubectl get service cat-svce --output=jsonpath='{.spec.ports[0].nodePort}')
        - nodePort2=$(kubectl get svc frontend --output=jsonpath='{.spec.ports[0].nodePort}')
        - kubectl describe deployment catalogue-service-deployment
        - kubectl describe service cat-svce
        - kubectl describe service frontend
        - minikubeIP=$(minikube ip)  # local host machine's minikube VM IP        
        - clusterIP=$(kubectl get svc cat-svce -o json | jq -r '.spec.clusterIP')
        - echo $nodePort $minikubeIP $clusterIP
        #- curl -s http://${minikubeIP}:${nodePort2}/
        - curl http://${minikubeIP}:${nodePort2}/search | jq '.'
        - curl http://${minikubeIP}:${nodePort}/search | jq '.'
        - curl -si http://${minikubeIP}:${nodePort2}/search
        - curl -si http://${minikubeIP}:${nodePort}/search
        - kubectl logs deployment/frontend --all-containers=true

# Make sure created pod is scheduled and running.
#- JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}'; until kubectl -n default get pods -lapp=travis-example -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do sleep 1;echo "waiting for travis-example deployment to be available"; kubectl get pods -n default; done

notifications:
  email:
    recipients:
      - paul.cox@telespazio.com
      - richard.conway@telespazio.com
    on_success: never #never # default: change
    on_failure: never # default: always
